using Interpolations, LinearAlgebra

# Physical basis for SU(3). Needed for calculating the generalized classical sum rule.
function observable_matrices(; N=3)
    Sx, Sy, Sz = Sunny.spin_matrices(; N)
    Os = [
        Sx,
        Sy,
        Sz,
        -(Sx*Sz + Sz*Sx),
        -(Sy*Sz + Sz*Sy),
        Sx^2 - Sy^2,
        Sx*Sy + Sy*Sx,
        ‚àö3 * Sz^2 - I*2/‚àö3,
    ] 
    return Os
end

# These were the kappa values determined from a larger simulation than the example 
# code given in this repo. 
function Œ∫val(kT)
    Œ∫s  = [1.0003252089084083, 1.000052081209924, 1.0004306811209078, 1.0009849715732704, 1.0034194934150678, 1.0024435498594622, 1.0026632978438412, 1.004141862283583, 1.0036794093910342, 1.0038305701799048, 1.0041121981141743, 1.005424971983036, 1.0059729017445018, 1.0075700665396061, 1.0071528468901272, 1.007406321396858, 1.0081095550104688, 1.0075721342780979, 1.0118194520018338, 1.01099118480295, 1.0119100766156546, 1.01294932606809, 1.015339266892749, 1.0159785853179288, 1.017129063339887, 1.0193974838959798, 1.0205057313864543, 1.023321451460388, 1.0251944931565333, 1.026704075410071, 1.0294464922379114, 1.0317490444816024, 1.0354063667392661, 1.0383544322306104, 1.0425766515218438, 1.0456341555786361, 1.0484829719084288, 1.053839609037338, 1.059810528669266, 1.0641619490908565, 1.0699137721695227, 1.0765761446181514, 1.0855256445110804, 1.0943868222631867, 1.1045306700612483, 1.1167647192714394, 1.129253671529854, 1.1443654982838956, 1.162806555504363, 1.183826742844619, 1.2073557557803112, 1.2355886951894093, 1.2658915934863793, 1.2996222690700534, 1.3314146610700632, 1.3636214153911839, 1.3939144342124876, 1.4254280168454738, 1.4565399632891531, 1.486236363219084, 1.515010165696628, 1.5435196540124385, 1.5727471748150208, 1.600081514052062, 1.6266370768308924, 1.651762070978002, 1.6768779737999624, 1.7009847050037472, 1.7248167057557025, 1.7453003319720755, 1.7673866375689782, 1.786496038896737, 1.804087232312562, 1.82187216973074, 1.8382504982534493, 1.853431502211571, 1.8669887133615444, 1.8789616167271674, 1.8904180536300745, 1.900319455954342, 1.9103966711821632, 1.9180366164049787, 1.9257307456791641, 1.9319772240935245, 1.9380374594373362, 1.9434897532269422, 1.9481951240040836, 1.9523468798390917, 1.956144972296483, 1.9599939267082223, 1.962545429205236, 1.9652111170652198, 1.9674159438797312, 1.9695591453190127, 1.971363663416716, 1.9728759844157187, 1.9743126179427481, 1.9755615169658725, 1.9766971910832793, 1.977607544290041]
    kTs = [0.09999999999999999, 0.10722672220103237, 0.11497569953977357, 0.12328467394420665, 0.13219411484660287, 0.14174741629268053, 0.15199110829529333, 0.16297508346206444, 0.17475284000076832, 0.18738174228603843, 0.20092330025650462, 0.21544346900318836, 0.23101297000831597, 0.24770763559917106, 0.2656087782946686, 0.2848035868435801, 0.30538555088334146, 0.3274549162877728, 0.35111917342151305, 0.3764935806792469, 0.4037017258596556, 0.4328761281083059, 0.4641588833612779, 0.49770235643321115, 0.533669923120631, 0.5722367659350217, 0.6135907273413173, 0.6579332246575679, 0.7054802310718643, 0.7564633275546288, 0.811130830789687, 0.8697490026177835, 0.93260334688322, 1.0000000000000002, 1.0722672220103233, 1.1497569953977358, 1.2328467394420661, 1.321941148466029, 1.4174741629268053, 1.5199110829529336, 1.629750834620644, 1.747528400007684, 1.873817422860384, 2.009233002565047, 2.1544346900318834, 2.3101297000831593, 2.4770763559917106, 2.656087782946687, 2.848035868435802, 3.0538555088334154, 3.274549162877728, 3.511191734215131, 3.764935806792468, 4.037017258596555, 4.328761281083058, 4.641588833612779, 4.977023564332111, 5.3366992312063095, 5.722367659350217, 6.1359072734131725, 6.579332246575679, 7.054802310718643, 7.5646332755462895, 8.111308307896872, 8.697490026177833, 9.326033468832199, 10.0, 10.722672220103233, 11.497569953977358, 12.328467394420661, 13.219411484660291, 14.174741629268052, 15.199110829529339, 16.297508346206442, 17.47528400007684, 18.738174228603842, 20.092330025650472, 21.54434690031884, 23.1012970008316, 24.77076355991711, 26.560877829466865, 28.480358684358016, 30.538555088334157, 32.74549162877729, 35.111917342151315, 37.64935806792469, 40.370172585965555, 43.28761281083059, 46.415888336127786, 49.77023564332111, 53.36699231206311, 57.223676593502184, 61.35907273413174, 65.7933224657568, 70.54802310718644, 75.64633275546288, 81.11308307896873, 86.97490026177834, 93.26033468832199, 100.00000000000001] 
    if kT < 0.1 
        return 1.0
    elseif kT > 100.0
        return 2.0
    end
    return linear_interpolation(kTs, Œ∫s)(kT)
end

# Calculate the the integral of S(ùê™, œâ) over both ùê™ and œâ.
function total_spectral_weight(sc::SampledCorrelations; kT = Inf)
    qs = available_wave_vectors(sc)
    formula = intensity_formula(sc, :trace; kT)
    is = intensities_interpolated(sc, qs, formula; interpolation=:round, negative_energies=true)
    return sum(is)
end

# Renormalize kets and adjust Œ∫s in system so renormalization is applied
# when running the dynamics.
function renormalize_system!(sys, coherents, Œ∫)
    sys.Œ∫s .= Œ∫
    for site in Sunny.eachsite(sys)
        set_coherent!(sys, coherents[site], site)
    end
    return nothing
end

# Estimate S(ùê™,œâ) at temperature kT and evaluate the sum rule using both the
# classical-to-quantum correspondence factor and moment renormalization. For the
# publication results, the intensities at the ordering wave vector were
# integrated out prior to applying the classical-to-quantum correspondence
# factor whenever T < T_N. In other words, the classical-to-quantum rescaling
# was only applied to the inelastic response.
function estimate_sum(sys::System{N}, Œ∫, kT, sim_params; observables=nothing) where N
    (; nœâ, œâmax, Œît, Œît_therm, dur_therm, dur_decorr, nsamples, Œª) = sim_params

    sc = dynamical_correlations(sys; Œît, nœâ, œâmax, observables)
    saved_coherents = copy(sys.coherents)
    ndecorr = round(Int, dur_decorr/Œît_therm)
    ntherm = round(Int, dur_therm/Œît_therm)

    # Thermalize the system
    langevin = Langevin(Œît_therm; Œª, kT = kT*Sunny.meV_per_K)
    for _ in 1:ntherm
        step!(sys, langevin)
    end

    # Collect samples
    for _ in 1:nsamples

        # Get a decorrelated equilibrium sample 
        for _ in 1:ndecorr
            step!(sys, langevin)
        end

        # Save the sampled state
        saved_coherents .= sys.coherents

        # Renormalize kets before running dynamics to collect a trajectory and associated correlations.
        renormalize_system!(sys, sys.coherents, Œ∫)
        add_sample!(sc, sys)

        # Un-renormalize kets and return to previous state before continuing
        # Langevin sampling process in next iteration.
        renormalize_system!(sys, saved_coherents, 1.0)
    end

    # Return spectral weight per site.
    return total_spectral_weight(sc; kT = kT*Sunny.meV_per_K) / length(Sunny.eachsite(sys))
end